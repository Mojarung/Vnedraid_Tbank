# Детальный план проекта: ИИ-агрегатор новостей для трейдеров

Этот документ описывает план разработки новостного агрегатора на базе ИИ для розничных трейдеров.

## 1. Настройка проекта

- **Цель**: Инициализировать структуру проекта для бэкенда, фронтенда и общих сервисов.
- **Задачи**:
    1.  Создать структуру монорепозитория (или отдельных репозиториев) с директориями `backend`, `frontend`, `document-processor`.
    2.  Настроить `docker-compose.yml` для локальной разработки, определив сервисы для бэкенда, фронтенда, базы данных (PostgreSQL) и Redis (для кэширования).
    3.  Инициализировать проект бэкенда:
        - Окружение Python с помощью `venv` или `poetry`.
        - Установить FastAPI, Uvicorn, SQLAlchemy, Alembic, Pydantic и другие зависимости.
        - Создать начальную структуру в `backend/src`: `main.py`, `routers/`, `models/`, `schemas/`, `core/`, `crud/`, `db/`.
    4.  Инициализировать проект фронтенда:
        - Использовать Vite для создания нового проекта React + TypeScript в `frontend/`.
        - Установить Tailwind CSS и Shadcn UI.
        - Настроить `vite.config.ts`, `tailwind.config.js`, `postcss.config.js`, `tsconfig.json`.
    5.  Создать `.env.example` с необходимыми переменными окружения для подключения к базе данных, API-ключей и т.д.

## 2. Разработка бэкенда (FastAPI)

- **Цель**: Создать масштабируемый и надежный API для предоставления новостных данных.

### 2.1. База данных и модели (SQLAlchemy)

- **Задачи**:
    1.  Спроектировать схему базы данных. Ключевые таблицы:
        - `sources` (id, name, url, type (RSS, Telegram и т.д.))
        - `news_items` (id, source_id, title, content, original_url, publication_date)
        - `tickers` (id, symbol, company_name)
        - `news_item_tickers` (ассоциативная таблица между news_items и tickers)
        - `summaries` (id, news_item_id, summary_text, sentiment_score, generated_at)
        - `user_tracked_tickers` (user_id, ticker_id) - предполагая модель пользователя в будущем, пока может быть на основе сессий.
    2.  Реализовать модели SQLAlchemy для этих таблиц в `backend/src/models/`.
    3.  Настроить Alembic для миграций базы данных. Создать начальную миграцию.

### 2.2. Сбор данных (`document-processor`)

- **Цель**: Собирать новости из различных источников. Это должен быть отдельный, масштабируемый сервис или набор фоновых задач.
- **Задачи**:
    1.  Реализовать парсеры для различных типов источников:
        - **RSS-ленты**: Использовать библиотеку `feedparser`.
        - **Telegram-каналы**: Использовать `telethon` или `pyrogram`. Потребуются учетные данные.
        - **Веб-скрапинг**: Использовать `httpx` и `BeautifulSoup` или `Scrapy` для сайтов типа `tradingview.com`. Учитывать их `robots.txt` и условия использования.
    2.  Создать планировщик (например, `apscheduler` в FastAPI или отдельный воркер Celery/Dramatiq) для периодического получения новых статей.
    3.  Сохранять сырые полученные статьи в таблице `news_items`.
    4.  Реализовать логику для избежания дубликатов (например, на основе URL или хэша контента).

### 2.3. Интеграция NLP и ИИ

- **Цель**: Обрабатывать сырые новости для извлечения инсайтов. Это также может быть частью фонового конвейера обработки.
- **Задачи**:
    1.  **Извлечение тикеров**:
        - Использовать регулярные выражения и словарь известных тикеров и названий российских компаний.
        - Для более продвинутого подхода использовать модель Named Entity Recognition (NER), дообученную на финансовых сущностях. `Natasha` или `DeepPavlov` могут быть отправными точками для русского языка.
    2.  **Суммаризация и интерпретация**:
        - Интегрироваться с LLM API (GPT, Claude и т.д.).
        - Разработать промпты для генерации резюме, интерпретации влияния новостей и, возможно, предоставления прогноза. Инженерия промптов будет ключевым моментом. Пример промпта: `"Сделай резюме следующей финансовой новости и объясни ее потенциальное влияние на [Название компании] (Тикер: [ТИКЕР]). Является ли настроение позитивным, негативным или нейтральным для акции? Статья: [Текст статьи]"`.
    3.  **Анализ настроений**: LLM может предоставлять это как часть резюме, или можно использовать отдельную, более легкую модель.
    4.  Сохранять результаты в `summaries` и связывать тикеры в `news_item_tickers`.

### 2.4. Эндпоинты API (Роутеры FastAPI)

- **Цель**: Предоставлять данные фронтенду.
- **Задачи**:
    1.  `/api/v1/news_feed`:
        - `GET /`: Получить постраничную ленту новостей.
        - Параметры: `tickers` (список через запятую), `page`, `limit`.
        - Возвращает список обработанных новостей с резюме.
    2.  `/api/v1/daily_gazette`:
        - `GET /`: Получить «газетную» сводку за день.
        - Параметры: `tickers`.
        - Этот эндпоинт будет агрегировать самые важные новости за последние 24 часа.
    3.  `/api/v1/tickers`:
        - `GET /`: Получить список доступных для выбора тикеров.
        - `GET /search`: Поиск тикеров.
    4.  `/api/v1/sources`: (Административный/внутренний)
        - Эндпоинты для управления `sources`. `GET`, `POST`, `PUT`, `DELETE`.
    5.  Реализовать схемы Pydantic для валидации запросов и ответов в `backend/src/schemas/`.
    6.  Реализовать CRUD-операции в `backend/src/crud/`.
    7.  Реализовать бизнес-логику в файлах роутеров в `backend/src/routers/`.

## 3. Разработка фронтенда (React + TypeScript)

- **Цель**: Создать интуитивно понятный и отзывчивый пользовательский интерфейс.

### 3.1. Основные UI-компоненты (Shadcn UI)

- **Задачи**:
    1.  Настроить базовый макет: `Header`, `Sidebar` (для выбора тикеров), `MainContent`.
    2.  Создать переиспользуемые компоненты с помощью Shadcn UI:
        - `Card` для отображения одной новости.
        - `Button`, `Input`, `Checkbox` для элементов управления.
        - `Sheet` или `Dialog` для настроек или выбора тикеров.
        - `DataTable` для более структурированного вида, если потребуется.
        - `Skeleton` для состояний загрузки.

### 3.2. Страницы и представления

- **Задачи**:
    1.  **Представление основной ленты**:
        - Это будет главная страница (`/`).
        - Загружает и отображает новости с `/api/v1/news_feed`.
        - Реализует бесконечную прокрутку или пагинацию.
        - Позволяет фильтровать по тикерам.
    2.  **Представление «Ежедневной газеты»**:
        - Отдельная страница (`/gazette`) или специальный раздел на главной странице.
        - Загружает и отображает агрегированную сводку с `/api/v1/daily_gazette`.
    3.  **Выбор тикеров**:
        - Интуитивно понятный интерфейс для поиска и выбора отслеживаемых тикеров. Состояние можно управлять в `localStorage` или параметрах URL для простоты.

### 3.3. Управление состоянием и загрузка данных

- **Задачи**:
    1.  Использовать библиотеку для загрузки данных, такую как `react-query` (`@tanstack/react-query`), для обработки запросов к API, кэширования и серверного состояния.
    2.  Для клиентского состояния (например, выбранные тикеры) использовать `useState` и `useContext` для простых случаев или легковесный менеджер состояний, такой как `Zustand`, если сложность возрастет.
    3.  Реализовать правильные состояния загрузки и ошибок для всех операций по загрузке данных.

## 4. Развертывание и CI/CD

- **Цель**: Автоматизировать развертывание и обеспечить стабильную производственную среду.
- **Задачи**:
    1.  **Докеризация**:
        - Создать `Dockerfile` для производственных сборок (бэкенд и фронтенд).
        - Использовать многоступенчатые сборки, чтобы образы были маленькими.
    2.  **Оркестрация**:
        - Создать `docker-compose.prod.yml` (или аналогичный) для производственного развертывания.
        - Он будет запускать бэкенд, раздавать статические файлы фронтенда (например, через Nginx) и подключаться к производственной базе данных и другим сервисам.
    3.  **CI/CD Pipeline**:
        - Настроить рабочий процесс GitHub Actions (или аналогичный).
        - При пуше в ветку `main`:
            - Запускать тесты (бэкенд и фронтенд).
            - Собирать Docker-образы.
            - Отправлять образы в реестр контейнеров (например, Docker Hub, GitHub Container Registry).
            - Развертывать на сервере (например, с помощью `ssh` для загрузки новых образов и перезапуска сервисов).

## 5. Тестирование

- **Цель**: Обеспечить надежность приложения.
- **Задачи**:
    1.  **Бэкенд**:
        - Модульные тесты для CRUD-операций и бизнес-логики с помощью `pytest`.
        - Интеграционные тесты для эндпоинтов API с помощью `httpx` и тестовой базы данных.
    2.  **Фронтенд**:
        - Модульные тесты для компонентов и утилитарных функций с помощью `Vitest` и `React Testing Library`.